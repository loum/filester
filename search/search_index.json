{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Filester: generic, file based utilities and helpers","text":"<p>Find yourself running the same file based operations over and over again in your projects? Yeah, annoying. As a result, this package is a grouping of common file operation facilities which delegate the package inclusion to <code>pip</code> and PyPI. One less thing to worry about ...</p>"},{"location":"reference/filester/","title":"filester","text":"<p>Generic, file-based utilities and helpers.</p>"},{"location":"reference/filester/#filester.check_filename","title":"<code>check_filename(filename, re_format)</code>","text":"<p>Parse filename string supplied by <code>file</code> and check that it conforms to <code>re_format</code>.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename string.</p> required <code>re_format</code> <code>str</code> <p>The regular expression format string to match against.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Boolean <code>True</code> if filename string conforms to <code>re_format</code>. Otherwise <code>False</code>.</p> Source code in <code>filester/__init__.py</code> <pre><code>def check_filename(filename: str, re_format: str) -&gt; bool:\n\"\"\"Parse filename string supplied by `file` and check that it conforms to `re_format`.\n    Parameters:\n        filename: The filename string.\n        re_format: The regular expression format string to match against.\n    Returns:\n        Boolean `True` if filename string conforms to `re_format`. Otherwise `False`.\n    \"\"\"\nstatus = False\nreg_c = re.compile(re_format)\nreg_match = reg_c.match(os.path.basename(filename))\nif reg_match:\nstatus = True\nlog.debug('File \"%s\" matches filter \"%s\"', filename, re_format)\nelse:\nlog.debug('File \"%s\" did not match filter \"%s\"', filename, re_format)\nreturn status\n</code></pre>"},{"location":"reference/filester/#filester.copy_file","title":"<code>copy_file(source, target)</code>","text":"<p>Attempts to copy <code>source</code> to <code>target</code>.</p> <p>Guarantees an atomic copy.  In other word, <code>target</code> will not present on the filesystem until the copy is complete.</p> <p>Checks if the <code>target</code> directory exists.  If not, will attempt to create before attempting the file move.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Name of file to move.</p> required <code>target</code> <code>str</code> <p>Name of file where to move <code>source</code> to.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Boolean <code>True</code> if move was successful. Otherwise <code>False</code>.</p> Source code in <code>filester/__init__.py</code> <pre><code>def copy_file(source: str, target: str) -&gt; bool:\n\"\"\"Attempts to copy `source` to `target`.\n    Guarantees an atomic copy.  In other word, `target` will not present\n    on the filesystem until the copy is complete.\n    Checks if the `target` directory exists.  If not, will attempt to\n    create before attempting the file move.\n    Parameters:\n        source: Name of file to move.\n        target: Name of file where to move `source` to.\n    Returns:\n        Boolean `True` if move was successful. Otherwise `False`.\n    \"\"\"\nlog.info('Copying \"%s\" to \"%s\"', source, target)\nstatus = False\nif os.path.exists(source):\nif create_dir(os.path.dirname(target)):\ntry:\ntmp_dir = os.path.dirname(target)\nwith tempfile.NamedTemporaryFile(dir=tmp_dir) as _fh:\ntmp_target = _fh.name\n_fh.close()\nshutil.copyfile(source, tmp_target)\nos.rename(tmp_target, target)\nstatus = True\nexcept (OSError, IOError) as err:\nlog.error('%s copy to %s failed: \"%s\"', source, target, err)\nelse:\nlog.warning('Source file \"%s\" does not exist', str(source))\nreturn status\n</code></pre>"},{"location":"reference/filester/#filester.create_dir","title":"<code>create_dir(directory)</code>","text":"<p>Helper method to manage the creation of a directory.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str</code> <p>Name of the directory structure to create.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Boolean <code>True</code> if directory is created or already exists. Boolean <code>False</code> otherwise.</p> Source code in <code>filester/__init__.py</code> <pre><code>def create_dir(directory: str) -&gt; bool:\n\"\"\"Helper method to manage the creation of a directory.\n    Parameters:\n        directory: Name of the directory structure to create.\n    Returns:\n        Boolean `True` if directory is created or already exists. Boolean `False` otherwise.\n    \"\"\"\nstatus = True\nif directory is not None:\nif not os.path.exists(directory):\nlog.info('Creating directory \"%s\"', directory)\ntry:\nos.makedirs(directory)\nexcept OSError as err:\nstatus = False\nlog.error(\"Directory create error: %s\", err)\nelse:\nlog.error('Create directory failed - invalid name \"%s\"', directory)\nreturn status\n</code></pre>"},{"location":"reference/filester/#filester.gen_digest","title":"<code>gen_digest(value, digest_len=8)</code>","text":"<p>Generates a 64-bit checksum against <code>value</code>.</p> <p>The digest is the first 8-bytes of the <code>hashlib.hexdigest</code> function.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Optional[Union[str, int]]</code> <p>The string value to generate digest against.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>An 8 byte digest containing only hexadecimal digits.</p> Source code in <code>filester/__init__.py</code> <pre><code>def gen_digest(value: Optional[Union[str, int]], digest_len: int = 8) -&gt; Optional[str]:\n\"\"\"Generates a 64-bit checksum against `value`.\n    The digest is the first 8-bytes of the `hashlib.hexdigest` function.\n    Parameters:\n        value: The string value to generate digest against.\n    Returns:\n        An 8 byte digest containing only hexadecimal digits.\n    \"\"\"\ndigest = None\nif value is not None and isinstance(value, str):\nmd5 = hashlib.md5()\nmd5.update(bytes(value, encoding=\"utf-8\"))\ndigest = md5.hexdigest()[0:digest_len]\nelse:\nlog.error(\"Cannot generate digest against value: %s\", str(value))\nreturn digest\n</code></pre>"},{"location":"reference/filester/#filester.gen_digest_path","title":"<code>gen_digest_path(value, dir_depth=4)</code>","text":"<p>Helper function that handles the creation of digest-based directory path.  The digest is calculated from <code>value</code>. For example, the <code>value</code> <code>193433</code> will generate the directory path list: <pre><code>['73', '73b0', '73b0b6', '73b0b66e']\n</code></pre></p> <p>Depth of directories created can be controlled by <code>dir_depth</code>.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The string value to generate digest against.</p> required <code>dir_depth</code> <code>int</code> <p>number of directory levels (default 4).  For example, depth of 2 would produce: <pre><code>['73', 73b0']\n</code></pre></p> <code>4</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>list of 8-byte segments that constitite the original 32-byte digest.</p> Source code in <code>filester/__init__.py</code> <pre><code>def gen_digest_path(value: str, dir_depth: int = 4) -&gt; list[str]:\n\"\"\"Helper function that handles the creation of digest-based\n    directory path.  The digest is calculated from `value`.\n    For example, the `value` `193433` will generate the directory path list:\n    ```\n    ['73', '73b0', '73b0b6', '73b0b66e']\n    ```\n    Depth of directories created can be controlled by `dir_depth`.\n    Parameters:\n        value: The string value to generate digest against.\n        dir_depth: number of directory levels (default 4).  For example,\n            depth of 2 would produce:\n            ```\n            ['73', 73b0']\n            ```\n    Returns:\n        list of 8-byte segments that constitite the original 32-byte digest.\n    \"\"\"\ndigest = gen_digest(value)\ndirs = []\nif digest is not None:\ndirs = [digest[0 : 2 + (i * 2)] for i in range(0, dir_depth)]\nreturn dirs\n</code></pre>"},{"location":"reference/filester/#filester.get_directory_files","title":"<code>get_directory_files(file_path, file_filter=None)</code>","text":"<p>Generator that returns the files in the directory given by <code>file_path</code>.</p> <p>Does not include the special entries <code>.</code> and <code>..</code> even if they are present in the directory.</p> <p>If <code>file_filter</code> is provided, will perform a regular expression match against the files within <code>file_path</code>.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Absolute path name to the directory.</p> required <code>file_filter</code> <code>Optional[str]</code> <p>Regular expression type pattern that can be input directly into the <code>re.search</code> function</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[str]</code> <p>Each file in the directory as a generator object.</p> Source code in <code>filester/__init__.py</code> <pre><code>def get_directory_files(\nfile_path: str, file_filter: Optional[str] = None\n) -&gt; Iterator[str]:\n\"\"\"Generator that returns the files in the directory given by `file_path`.\n    Does not include the special entries `.` and `..` even if they are\n    present in the directory.\n    If `file_filter` is provided, will perform a regular expression match\n    against the files within `file_path`.\n    Parameters:\n        file_path: Absolute path name to the directory.\n        file_filter: Regular expression type pattern that can be input directly\n            into the `re.search` function\n    Returns:\n        Each file in the directory as a generator object.\n    \"\"\"\ndirectory_files = []\ntry:\ndirectory_files = os.listdir(file_path)\nexcept (TypeError, OSError) as err:\nlog.error(\"Directory listing error for %s: %s\", file_path, err)\nfor this_file in directory_files:\nthis_file = os.path.join(file_path, this_file)\nif not os.path.isfile(this_file):\ncontinue\nif file_filter is None:\nyield this_file\nelse:\nif fnmatch.fnmatch(os.path.basename(this_file), file_filter):\nyield this_file\n</code></pre>"},{"location":"reference/filester/#filester.get_directory_files_list","title":"<code>get_directory_files_list(file_path, file_filter=None)</code>","text":"<p>Wrapper around the <code>get_directory_files</code> function that returns a list of files in the directory denoted by <code>file_path</code>.</p> Source code in <code>filester/__init__.py</code> <pre><code>def get_directory_files_list(\nfile_path: str, file_filter: Optional[str] = None\n) -&gt; list[Optional[str]]:\n\"\"\"Wrapper around the `get_directory_files` function that\n    returns a list of files in the directory denoted by `file_path`.\n    \"\"\"\nreturn list(get_directory_files(file_path, file_filter))\n</code></pre>"},{"location":"reference/filester/#filester.get_file_time_in_utc","title":"<code>get_file_time_in_utc(filename)</code>","text":"<p>Will attempt to read <code>filename</code> modified time stamp and return a RFC 3339-compliant string in UTC.</p> <p>If time can not be obtained then <code>None</code> is returned</p> Source code in <code>filester/__init__.py</code> <pre><code>def get_file_time_in_utc(filename: str) -&gt; Optional[str]:\n\"\"\"Will attempt to read `filename` modified time stamp and return\n    a RFC 3339-compliant string in UTC.\n    If time can not be obtained then `None` is returned\n    \"\"\"\nutc_time_str = None\nif os.path.isfile(filename):\nsec_since_epoch = os.stat(filename)[8]\nutc_time_str = time.strftime(\"%Y-%m-%dT%H:%M:%SZ\", time.gmtime(sec_since_epoch))\nreturn utc_time_str\n</code></pre>"},{"location":"reference/filester/#filester.move_file","title":"<code>move_file(source, target, dry=False)</code>","text":"<p>Attempts to move <code>source</code> to <code>target</code>.</p> <p>Checks if the <code>target</code> directory exists.  If not, will attempt to create before attempting the file move.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Name of file to move.</p> required <code>target</code> <code>str</code> <p>Name of file where to move <code>source</code> to.</p> required <code>dry</code> <code>bool</code> <p>Only report, do not execute (but will create the target directory if it is missing).</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>Boolean <code>True</code> if move was successful. Otherwise boolean <code>False</code>.</p> Source code in <code>filester/__init__.py</code> <pre><code>def move_file(source: str, target: str, dry: bool = False) -&gt; bool:\n\"\"\"Attempts to move `source` to `target`.\n    Checks if the `target` directory exists.  If not, will attempt to\n    create before attempting the file move.\n    Parameters:\n        source: Name of file to move.\n        target: Name of file where to move `source` to.\n        dry: Only report, do not execute (but will create the target directory if it is missing).\n    Returns:\n        Boolean `True` if move was successful. Otherwise boolean `False`.\n    \"\"\"\nlog.info('Moving \"%s\" to \"%s\"', source, target)\nstatus = True\nif not os.path.exists(source):\nlog.warning('Source file \"%s\" does not exist', str(source))\nstatus = False\nelse:\ndir_status = True\ndirectory = os.path.dirname(target)\nif len(directory):\ndir_status = create_dir(directory)\nif not dry and dir_status:\ntry:\nos.rename(source, target)\nexcept OSError as error:\nstatus = False\nlog.error('%s move to %s failed: \"%s\"', source, target, error)\nreturn status\n</code></pre>"},{"location":"reference/filester/#filester.remove_files","title":"<code>remove_files(files)</code>","text":"<p>Attempts to remove <code>files</code>.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>Union[str, list[str]]</code> <p>Either a list of files to remove or a single filename.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list of files successfully removed from filesystem</p> Source code in <code>filester/__init__.py</code> <pre><code>def remove_files(files: Union[str, list[str]]) -&gt; list[str]:\n\"\"\"Attempts to remove `files`.\n    Parameters:\n        files: Either a list of files to remove or a single filename.\n    Returns:\n        list of files successfully removed from filesystem\n    \"\"\"\nif not isinstance(files, list):\nfiles = [files]\nfiles_removed = []\nfor file_to_remove in files:\ntry:\nlog.info('Removing file \"%s\"', file_to_remove)\nos.remove(file_to_remove)\nfiles_removed.append(file_to_remove)\nexcept OSError as err:\nlog.error('\"%s\" remove failed: %s', file_to_remove, err)\nreturn files_removed\n</code></pre>"},{"location":"reference/filester/#filester.templater","title":"<code>templater(template_file, **kwargs)</code>","text":"<p>Attemptes to parse <code>template</code> file and substitute template parameters with <code>kwargs</code> construct.</p> <p>Parameters:</p> Name Type Description Default <code>template_file</code> <code>str</code> <p>Fully qualified path to the template file.</p> required <code>kwargs</code> <code>dict</code> <p>Dictionary structure of items to expected by the HTML email templates: <pre><code>{\n    \"name\": \"Anywhere\",\n    \"address\": \"1234 Anywhere Road\",\n    \"suburb\": \"ANYWHERE\",\n    \"postcode\": \"9999\",\n    \"barcode\": \"0123456789-barcode\",\n    \"item_nbr\": \"0123456789-item_nbr\",\n}\n</code></pre></p> <code>{}</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>String representation of the template with parameters substition or <code>None</code> if the process fails.</p> <p>Raises:</p> Type Description <code>IOError</code> <p>If the template_file cannot be opened.</p> <code>KeyError</code> <p>if the template substitution fails</p> Source code in <code>filester/__init__.py</code> <pre><code>def templater(template_file: str, **kwargs: dict) -&gt; Optional[str]:\n\"\"\"Attemptes to parse `template` file and substitute template parameters\n    with `kwargs` construct.\n    Parameters:\n        template_file: Fully qualified path to the template file.\n        kwargs: Dictionary structure of items to expected by the HTML email templates:\n            ```\n            {\n                \"name\": \"Anywhere\",\n                \"address\": \"1234 Anywhere Road\",\n                \"suburb\": \"ANYWHERE\",\n                \"postcode\": \"9999\",\n                \"barcode\": \"0123456789-barcode\",\n                \"item_nbr\": \"0123456789-item_nbr\",\n            }\n            ```\n    Returns:\n        String representation of the template with parameters substition\n            or `None` if the process fails.\n    Raises:\n        IOError: If the template_file cannot be opened.\n        KeyError: if the template substitution fails\n    \"\"\"\nlog.debug('Processing template: \"%s\"', template_file)\ntemplate_src = None\ntry:\nwith open(template_file, encoding=\"utf-8\") as _fh:\ntemplate_src = _fh.read()\nexcept IOError as err:\nlog.error('Unable to source template file \"%s\": %s', template_file, err)\ntemplate_sub = None\nif template_src is not None:\ntemplate = string.Template(template_src)\ntry:\ntemplate_sub = template.substitute(kwargs)\nexcept KeyError as err:\nlog.error('Template \"%s\" substitute failed: %s', template_file, err)\nif template_sub is not None:\ntemplate_sub = template_sub.rstrip(\"\\n\")\nlog.debug(\n'Template substitution (%s|%s) produced: \"%s\"',\ntemplate_file,\nstr(kwargs),\ntemplate_sub,\n)\nreturn template_sub\n</code></pre>"}]}